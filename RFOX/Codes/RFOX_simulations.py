"""RFOX.ipynb

Automatically generated by Colab.

Author: Ph.D.(c) Brian García Sarmina 15/08/2025 version 2.1

Original file is located at
    https://colab.research.google.com/drive/---
"""


import numpy as np
from itertools import product
from fractions import Fraction
import qiskit
import pickle
from scipy.stats import gmean
from scipy.linalg import logm
from scipy.sparse.linalg import eigsh
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
from qiskit_aer import AerSimulator
from qiskit.visualization import plot_histogram, plot_bloch_multivector
from qiskit.quantum_info import Operator, SparsePauliOp, Pauli
import matplotlib.pyplot as plt
from sklearn import preprocessing
import networkx as nx

"""###################### RFOX  AND COMPARISON MODELS ##############################"""

### WALSH-HADAMARD TRANSFORM ###
def walsh(qc, q_reg):
  for x in q_reg:
    qc.h(x)
  qc.barrier()
### PHASE INTERFERENCE ##
def phase_int(qc, q_reg, c_reg, phases):
  for j in range(len(phases)):
    ### Strategy for complex problem, [-1, 1] fields.
    qc.p(phases[j], q_reg[j])
  qc.barrier()

### RFOX algorithm BASED IN RXX-RZX GATES ###
def cone_t_ev(qc, q_reg, conexions, delta_t_1, delta_t_2, p, phases):
  for i in range(p):
    ### DRIVER HAMILTONIAN RZX TYPE ###
    for con in conexions:
      qc.rxx((1 - delta_t_2[i]), con[1], con[0])
      qc.rzx(delta_t_1[i], con[1], con[0])

### Vanilla Adiabatic approach ###
def cone(qc, q_reg, conexions, delta_t, p, phases, campos):
  for i in range(len(delta_t)):
    for k in range(len(campos)):
      qc.rx((1-delta_t[i]), q_reg[k])
    ### MAGNETIC FIELD ENCODING ###
    for j in range(len(campos)):
      qc.rz(delta_t[i]*campos[j], q_reg[j])
    qc.barrier()
    for con in conexions:
      qc.rzz(delta_t[i], con[0], con[1])
    qc.barrier()

### XX-DRIVER HAMILTONIAN ###
def cone_t_ev_driver(qc, q_reg, conexions, delta_t, p, phases, campos):
  j_xx = 1
  for i in range(len(delta_t)):
    ### DRIVER HAMILTONIAN RXX TYPE ###
    for con in conexions:
      qc.rxx(j_xx*(1-delta_t[i]), con[0], con[1])
    qc.barrier()
    ### MAGNETIC FIELD ENCODING ###
    for j in range(len(campos)):
      qc.rz(-1*delta_t[i]*campos[j], q_reg[j])
    qc.barrier()
    for con in conexions:
      qc.rzz(-1*delta_t[i], con[0], con[1])
    qc.barrier()

### X + sXX-DRIVER HAMILTONIAN ###
def cone_t_ev_driver_plus(qc, q_reg, conexions, delta_t, p, phases, campos):
  j_x_xx = 1
  for i in range(len(delta_t)):
    for k in range(len(campos)):
      qc.rx(-1*(1-delta_t[i]), q_reg[k])
    ### DRIVER HAMILTONIAN RXX TYPE ###
    for con in conexions:
      qc.rxx(j_x_xx*delta_t[i]*(1-delta_t[i]), con[0], con[1])
    qc.barrier()
    ### MAGNETIC FIELD ENCODING ###
    for j in range(len(campos)):
      qc.rz(-1*delta_t[i]*campos[j], q_reg[j])
    qc.barrier()
    for con in conexions:
      qc.rzz(-1*delta_t[i], con[0], con[1])
    qc.barrier()

### GENERATE FULL CIRCUIT ### WITHOUT INTERACTIONS
def full_circuit1(qc, q_reg, c_reg, phases, conexions, con_val):
  walsh(qc, q_reg)
  phase_int(qc, q_reg, c_reg, phases)
  walsh(qc, q_reg)
  qc.measure(q_reg, c_reg)

### GENERATE FULL CIRCUIT (X DRIVER "conventional adiabatic") ###
def full_circuit2(qc, q_reg, c_reg, phases, conexions, delta_t, p, campos):
  walsh(qc, q_reg)
  cone(qc, q_reg, conexions, delta_t, p, phases, campos)
  qc.measure(q_reg, c_reg)

### GENERATE FULL CIRCUIT RFOX (NON-Stoquastic + CD Floquet) ####
def full_circuit3(qc, q_reg, c_reg, phases, conexions, delta_t_1, delta_t_2, p):
  walsh(qc, q_reg)
  phase_int(qc, q_reg, c_reg, phases)
  walsh(qc, q_reg)
  cone_t_ev(qc, q_reg, conexions, delta_t_1, delta_t_2, p, phases)
  qc.barrier()
  qc.measure(q_reg, c_reg)

### GENERATE FULL CIRCUIT (XX-only DRIVER HAMILTONIAN) ####
def full_circuit4(qc, q_reg, c_reg, phases, conexions, delta_t, p, campos):
  walsh(qc, q_reg)
  cone_t_ev_driver(qc, q_reg, conexions, delta_t, p, phases, campos)
  qc.measure(q_reg, c_reg)

### GENERATE FULL CIRCUIT (X + sXX DRIVER HAMILTONIAN) ####
def full_circuit5(qc, q_reg, c_reg, phases, conexions, delta_t, p, campos):
  walsh(qc, q_reg)
  cone_t_ev_driver_plus(qc, q_reg, conexions, delta_t, p, phases, campos)
  qc.measure(q_reg, c_reg)

"""######################### ENERGY GAP ###########################################"""

# Parámetros del grafo:
q_num = 9
n = q_num          # número de nodos
p = 0.7         # probabilidad de que exista una conexión entre dos nodos
p_int = 5
h_range = (-2, 2)  # rango para los campos magnéticos

# Generar grafo aleatorio.
# G = nx.erdos_renyi_graph(n, p, seed=42)
G = nx.watts_strogatz_graph(n, p_int, p, seed=42)

# Asignar un campo magnético aleatorio a cada nodo
# magnetic_fields_test = [2.287124637056775, -2.1977565466623563, 0.7906728611642979, 2.2967969271631183, 1.68291034572474]
for node in G.nodes():
    G.nodes[node]['magnet_field'] = np.random.uniform(h_range[0], h_range[1])
    # G.nodes[node]['magnet_field'] = magnetic_fields_test[node]

# Obtener una disposición de los nodos para la visualización
#pos = nx.spring_layout((G), seed=42)
pos = nx.spring_layout((G))

# Preparar los valores del campo magnético para colorear los nodos
magnetic_fields = [G.nodes[node]['magnet_field'] for node in G.nodes()]

# Dibujar nodos con un mapa de colores (cmap) que refleje los valores de los campos magnéticos
nodes = nx.draw_networkx_nodes(G, pos, node_color=magnetic_fields, cmap=plt.cm.coolwarm, node_size=500, alpha=0.8)
print(magnetic_fields)
print(G.edges(data=True))

# Dibujar las aristas y etiquetas
nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.7)
nx.draw_networkx_labels(G, pos, font_color='white')

# Añadir barra de color para identificar el campo magnético
plt.colorbar(nodes, label='Magnetic field')

# Configurar título y quitar ejes
plt.title("RFIM Watts-Strogatz (EG)", fontsize=20)
plt.axis('off')

# Mostrar el grafo
plt.savefig('RFIM_Watts_Strogatz_EG.eps', format='eps', bbox_inches='tight')
plt.show()

# -------------------------------------------------------------------------
# 1.  Build reusable Pauli operators
# -------------------------------------------------------------------------
def build_xx_op(n_qubits, edges):
    """Sum_{(u,v)} X_u X_v as a SparsePauliOp (coeff = +1 for each edge)."""
    ops = []
    for (v, u) in edges:          # order matches RXX(v, u)
        label = ['I'] * n_qubits
        label[v] = label[u] = 'X'
        ops.append(SparsePauliOp(Pauli(''.join(reversed(label))), coeffs=[1.0]))
    return sum(ops)

def build_zx_op(n_qubits, edges):
    """Sum_{(u,v)} Z_v X_u  (control = v, target = u)."""
    ops = []
    for (v, u) in edges:          # order matches RZX(v, u)
        label = ['I'] * n_qubits
        label[v] = 'Z'
        label[u] = 'X'
        ops.append(SparsePauliOp(Pauli(''.join(reversed(label))), coeffs=[1.0]))
    return sum(ops)

def build_bias_op(n_qubits, varphi):
    """H_B = ½ Σ_j varphi_j X_j  (static X field)."""
    ops = []
    for j, phi in enumerate(varphi):
        label = ['I'] * n_qubits
        label[j] = 'X'
        ops.append(SparsePauliOp(Pauli(''.join(reversed(label))), coeffs=[phi]))
    return sum(ops)

# -------------------------------------------------------------------------
# 2.  Instantaneous Hamiltonian & gap
# -------------------------------------------------------------------------
def instantaneous_H(k, delta, N, p, H_xx, H_zx, H_bias):
    """Hamiltonian at slice k (0-based)."""
    theta_k = 1.0 - delta * np.cos(2 * np.pi * N * k / p)
    phi_k   =       delta * np.sin(2 * np.pi * N * k / p)
    return theta_k * H_xx + phi_k * H_zx + H_bias

def gap_sparse(op, k_eigs=2):
    """Return E1-E0 using sparse Lanczos (hermitian)."""
    mat = op.to_matrix(sparse=True)
    evals = eigsh(mat, k=k_eigs, which='SA', return_eigenvectors=False)
    evals.sort()
    return evals[1] - evals[0]

def rfox_gap_trace(G, varphi, delta=0.05, N=None, p=100):
    """
    Compute instantaneous gap Δ_k for all slices.

    Parameters
    ----------
    G       : networkx.Graph or list of edges
    varphi  : list or np.array of length n_qubits  (bias angles)
    delta   : harmonic amplitude
    N       : harmonic frequency (default = n_qubits)
    p       : number of slices (depth)
    """
    if N is None:
        N = len(varphi)

    edges = list(G.edges()) if hasattr(G, 'edges') else list(G)
    n_qubits = len(varphi)

    H_xx   = build_xx_op(n_qubits, edges)
    H_zx   = build_zx_op(n_qubits, edges)
    H_bias = build_bias_op(n_qubits, varphi)

    gaps = np.zeros(p)
    for k in range(p):
        H_k = instantaneous_H(k, delta, N, p, H_xx, H_zx, H_bias)
        gaps[k] = gap_sparse(H_k)

    return gaps

# ------------------------------------------------------------------
# 0.  Generic Pauli builders  (reuse across all schedules)
# ------------------------------------------------------------------
def _sum_pauli(n, pauli_string, coeff=1.0, qubits=None):
    """Return Σ_j coeff * P_j where P ∈ {X,Z}.
       If `qubits` is None, sum over all."""
    qubits = range(n) if qubits is None else qubits
    ops = []
    for j in qubits:
        label = ['I'] * n
        label[j] = pauli_string
        ops.append(SparsePauliOp(Pauli(''.join(reversed(label))), coeffs=[coeff]))
    return sum(ops)

def build_x_op(n):                     # Σ X_j
    return _sum_pauli(n, 'X', 1.0)

def build_z_field(n, h):               # Σ h_j Z_j
    return sum(_sum_pauli(n, 'Z', h_j, [j]) for j, h_j in enumerate(h))

def build_xx_op(n, edges):             # Σ X_u X_v
    ops = []
    for (u, v) in edges:
        label = ['I'] * n
        label[u] = label[v] = 'X'
        ops.append(SparsePauliOp(Pauli(''.join(reversed(label))), coeffs=[1.0]))
    return sum(ops)

def build_zz_op(n, edges):             # Σ Z_u Z_v
    ops = []
    for (u, v) in edges:
        label = ['I'] * n
        label[u] = label[v] = 'Z'
        ops.append(SparsePauliOp(Pauli(''.join(reversed(label))), coeffs=[1.0]))
    return sum(ops)

# ------------------------------------------------------------------
# 1.  Gap helper
# ------------------------------------------------------------------
def _gap(op):
    """Ground–first-excited gap using sparse Lanczos (small systems)."""
    vals = eigsh(op.to_matrix(sparse=True), k=2, which='SA', return_eigenvectors=False)
    vals.sort()
    return vals[1] - vals[0]

# ------------------------------------------------------------------
# 2.  Gap traces for each schedule
# ------------------------------------------------------------------
def gap_x_vanilla(G, fields, p, schedule=None):
    """
    Non-stoquastic X + sXX driver
    H(t) = (1-s)(-Σ X_j) + s (Σ h_j Z_j + Σ Z_u Z_v)
    """
    n = len(fields)
    edges = list(G.edges())
    H_x  = build_x_op(n)                     # Σ X_j
    H_zz = build_zz_op(n, edges)
    H_zf = build_z_field(n, fields)

    s_vals = schedule if schedule is not None else np.linspace(0, 1, p, endpoint=False)
    gaps = np.zeros(p)
    for k, s in enumerate(s_vals):
        H_k = (1-s)*H_x + s*(H_zz + H_zf)
        gaps[k] = _gap(H_k)
    return gaps

def gap_xx_driver(G, fields, p, schedule=None):
    """
    Stoquastic XX driver   H(t)= (1-s) (-Σ X_uX_v)  - s (Σ Z_j h_j + Σ Z_uZ_v)
    Parameters
    ----------
    schedule : array-like of length p with s_k in [0,1] (default linear)
    """
    n = len(fields)
    edges = list(G.edges())
    H_xx = build_xx_op(n, edges)             # Σ X_u X_v
    H_zz = build_zz_op(n, edges)             # Σ Z_u Z_v
    H_zf = build_z_field(n, fields)          # Σ h_j Z_j

    s_vals = schedule if schedule is not None else np.linspace(0, 1, p, endpoint=False)
    gaps = np.zeros(p)
    for k, s in enumerate(s_vals):
        H_k = (1-s)*H_xx - s*(H_zz + H_zf)
        gaps[k] = _gap(H_k)
    return gaps

def gap_x_plus_xx(G, fields, p, schedule=None):
    """
    Non-stoquastic X + sXX driver
    H(t) = -(1-s)(-Σ X_j)  +  (s(1-s)) Σ X_u X_v  - s (Σ h_j Z_j + Σ Z_u Z_v)
    """
    n = len(fields)
    edges = list(G.edges())
    H_x  = build_x_op(n)                     # Σ X_j
    H_xx = build_xx_op(n, edges)
    H_zz = build_zz_op(n, edges)
    H_zf = build_z_field(n, fields)

    s_vals = schedule if schedule is not None else np.linspace(0, 1, p, endpoint=False)
    gaps = np.zeros(p)
    for k, s in enumerate(s_vals):
        H_k = -(1-s)*H_x + s*(1-s)*H_xx - s*(H_zz + H_zf)
        gaps[k] = _gap(H_k)
    return gaps

g_delta_gap = G
campos = [datos['magnet_field'] for nodo, datos in G.nodes(data=True)]
print("Campos magnéticos:", campos)
#### Phase encoding para los campos magneticos ####
# Step 1: Divide by the largest absolute value
max_abs = np.max(np.abs(campos))
scaled = campos / max_abs
# Step 2: Shift and scale to [0,1]
normalized_data = (scaled + 1) / 2
normalized = np.array(normalized_data)
norm_phases = normalized*np.pi
print("Norm phases: ", norm_phases)
###################################################

varphi = norm_phases
fields = magnetic_fields
delta = 0.01
p = 100

# --- Gap traces ----------------------------------------------------
gaps_rfox = rfox_gap_trace(g_delta_gap, varphi=varphi,delta=delta, N=len(g_delta_gap), p=p)
gaps_x_vanilla = gap_x_vanilla(g_delta_gap, fields, p)
gaps_xx   = gap_xx_driver(g_delta_gap, fields, p)
gaps_x_xx = gap_x_plus_xx(g_delta_gap, fields, p)

# --- Plot ----------------------------------------------------------
s_axis = np.arange(p)/p
plt.plot(s_axis, gaps_rfox, label='RFOX', lw=2)
plt.plot(s_axis, gaps_xx,   label='XX driver', lw=1.5)
plt.plot(s_axis, gaps_x_xx, label='X + sXX', lw=1.5)
plt.plot(s_axis, gaps_x_vanilla, label='X (base)', lw=1.5)
plt.title("Energy gap comparison", fontsize=20)
plt.xlabel('Normalized slice index  $k/p$', fontsize=18)
plt.ylabel('Instantaneous gap  $\Delta_k$', fontsize=18)
plt.legend()
plt.tight_layout()
plt.savefig('RFIM_Watts_Strogatz_ENERGY_GAP_comp.eps', format='eps', bbox_inches='tight')
plt.show()

"""################# GENERAL TESTS (simulations for 150 instance sets) ###################################"""

# Parámetros del grafo:
q_num = 12
n = q_num          # número de nodos
p = 0.7         # 0.8 Erdos, 0.7 strogratz probabilidad de que exista una conexión entre dos nodos
h_range = (-5, 5)  # rango para los campos magnéticos
p_int = 6 # conexion con vecions para grafo "Watts-Strogatz".
number_of_graphs = 150
list_of_graphs = []

for i in range(number_of_graphs):
  # G = nx.erdos_renyi_graph(n, p, seed=42) # Generar grafo aleatorio (modelo de Erdős–Rényi)
  G = nx.watts_strogatz_graph(n, p_int, p, seed=42) # Generar grafo aleatorio (modelo de Watts-Strogatz)
  # Asignar un campo magnético aleatorio a cada nodo
  for node in G.nodes():
      G.nodes[node]['magnet_field'] = np.random.uniform(h_range[0], h_range[1])
  # Obtener una disposición de los nodos para la visualización
  #pos = nx.spring_layout((G), seed=42)
  pos = nx.spring_layout((G))
  # Preparar los valores del campo magnético para colorear los nodos
  magnetic_fields = [G.nodes[node]['magnet_field'] for node in G.nodes()]
  list_of_graphs.append(G)

### PROBAR MEJOR RESULTADO GENERADO ###
comb_pos = []
for bits_tuple in product('01', repeat=q_num):
  bits_str = ''.join(bits_tuple)
  comb_pos.append(bits_str)

def funcion_costo(combinacion, conexions, campos):
  costo = 0
  j_ij = 1
  ### INTERACCIONES ###
  for con in conexions:
    if combinacion[con[0]] == combinacion[con[1]]:
      costo += (-1*j_ij)
    else:
      costo += (1*j_ij)
  ### CAMPOS MAGNETICOS ##
  for i in range(len(combinacion)):
    ### Si el valor es "0" y el campo es negativo ###
    if combinacion[i] == '0' and campos[i] < 0:
      costo += campos[i]
    if combinacion[i] == '0' and campos[i] > 0:
      costo += campos[i]
    ### Si el valor es "1" y el campo es positivo ###
    if combinacion[i] == '1' and campos[i] > 0:
      costo += -1*campos[i]
    if combinacion[i] == '1' and campos[i] < 0:
      costo += -1*campos[i]
  return costo

def hamming_distance(s1, s2):
  if len(s1) != len(s2):
    raise ValueError("Bitstrings must be of the same length.")
  return sum(c1 != c2 for c1, c2 in zip(s1, s2))

### Numero de nodos = numero de qubits ###
n_exp = 10000 # Numero de experimentos
aersim = AerSimulator()
#### ADAPTIVE TIME EVOLUTION ####
t = 1           # tiempo total de evolución
p_zx = 100               # número de trozos
p_t = 100

def harmonic_delta_zx(t, delta, n_qubits):
    """
    Función armónica que oscila entre [-delta, +delta] en t∈[0,1],
    con exactamente n_qubits oscilaciones completas.
    """
    return delta * np.sin(2 * np.pi * n_qubits * t)
    # return delta * np.sin(2 * np.pi * n_qubits)

def harmonic_delta_xx(t, delta, n_qubits):
    """
    Función armónica que oscila entre [-delta, +delta] en t∈[0,1],
    con exactamente n_qubits oscilaciones completas.
    """
    return delta * np.cos(2 * np.pi * n_qubits * t)
    # return delta * np.cos(2 * np.pi * n_qubits)

### DRIVER HAMILTONIAN TIME EVOLUTION ####
delta_t_driver = np.linspace(0, 1, p_t)
delta_t = delta_t_driver

delta = 0.001           # amplitud pequeña
n_qubits = q_num        # número de oscilaciones = número de qubits
t_vals = np.linspace(0, 1, p_zx)   # tiempos uniformes en [0,1]
delta_t_1 = harmonic_delta_zx(t_vals, delta, n_qubits)
delta_t_2 = harmonic_delta_xx(t_vals, delta, n_qubits)

### Save best answers for each simulation ###
theoretical_minima = []
best_answers_phase_encoding = []
best_answers_rzx_time_evolution = []
best_answers_driver_hamiltonian_a = []
best_answers_driver_hamiltonian = []
best_answers_driver_hamiltonian2 = []
phase_eevs = []
rfox_eevs = []
driver_eevs_a = []
driver_eevs = []
driver2_eevs = []

for G in list_of_graphs:
  conexions = list(G.edges())
  campos = [datos['magnet_field'] for nodo, datos in G.nodes(data=True)]
  #### Phase encoding para los campos magneticos ####
  # Step 1: Divide by the largest absolute value
  max_abs = np.max(np.abs(campos))
  scaled = campos / max_abs
  # Step 2: Shift and scale to [0,1]
  normalized_data = (scaled + 1) / 2
  normalized = np.array(normalized_data)
  norm_phases = normalized*np.pi
  ###################################################
  q_reg = QuantumRegister(q_num)
  c_reg = ClassicalRegister(q_num)
  ###################################################

  ### TEST AND COMPARE APPROACHES ###

  #### THEORITICAL BEST RESULTS #####
  costos = [funcion_costo(comb, conexions, campos) for comb in comb_pos]
  costo_minimo = min(costos)
  ind_costo_minimo = costos.index(costo_minimo)
  # print("Globlal minimum cost: ", costo_minimo)
  # print("Theoretical minimum comb: ", comb_pos[ind_costo_minimo])
  theoretical_minima.append(costo_minimo)


  ### RFOX (NON-STOQUASTIC / FLOQUET CD EVOLUTION) ####
  qc = QuantumCircuit(q_reg, c_reg, name='qc_rzx_time')
  full_circuit3(qc, q_reg, c_reg, norm_phases, conexions, delta_t_1, delta_t_2, p_zx)
  job_sim = aersim.run(qc, shots=n_exp).result()
  answer = job_sim.get_counts(qc)
  rfox_eev = 0
  for key, value in answer.items():
    cost = funcion_costo(key, conexions, campos)
    rfox_eev += (cost*value)/n_exp
  rfox_eevs.append(rfox_eev)
  ######################
  ### SELECT MOST OCCURED RESULT ###
  most_occured_exp = max(answer, key=answer.get)
  most_occured_exp = most_occured_exp[::-1]
  rzx_best_cost = costos[comb_pos.index(most_occured_exp)]
  rzx_vs_theoritical_hamming = hamming_distance(most_occured_exp, comb_pos[ind_costo_minimo])
  best_answers_rzx_time_evolution.append([most_occured_exp, rzx_best_cost, rzx_vs_theoritical_hamming])
  #########################################################

  ### X-only driver vanilla ADIABATIC APPROACH ###
  qc_driver_a = QuantumCircuit(q_reg, c_reg, name='qc_driver_a')
  full_circuit2(qc_driver_a, q_reg, c_reg, campos, conexions, delta_t_driver, p, campos)
  job_sim_driver_a = aersim.run(qc_driver_a, shots=n_exp).result()
  answer_driver_a = job_sim_driver_a.get_counts(qc_driver_a)
  driver_eev_a = 0
  for key, value in answer_driver_a.items():
    cost = funcion_costo(key, conexions, campos)
    driver_eev_a += (cost*value)/n_exp
  driver_eevs_a.append(driver_eev_a)
  ######################
  ### SELECT MOST OCCURED RESULT ###
  most_occured_exp_driver_a = max(answer_driver_a, key=answer_driver_a.get)
  most_occured_exp_driver_a = most_occured_exp_driver_a[::-1]
  driver_best_cost_a = costos[comb_pos.index(most_occured_exp_driver_a)]
  driver_vs_theoritical_hamming_a = hamming_distance(most_occured_exp_driver_a, comb_pos[ind_costo_minimo])
  best_answers_driver_hamiltonian_a.append([most_occured_exp_driver_a, driver_best_cost_a, driver_vs_theoritical_hamming_a])
  #########################################################

  ### HAMILTONIAN XX-only DRIVER APPROACH ###
  qc_driver = QuantumCircuit(q_reg, c_reg, name='qc_driver')
  full_circuit4(qc_driver, q_reg, c_reg, campos, conexions, delta_t_driver, p, campos)
  job_sim_driver = aersim.run(qc_driver, shots=n_exp).result()
  answer_driver = job_sim_driver.get_counts(qc_driver)
  driver_eev = 0
  for key, value in answer_driver.items():
    cost = funcion_costo(key, conexions, campos)
    driver_eev += (cost*value)/n_exp
  driver_eevs.append(driver_eev)
  ######################
  ### SELECT MOST OCCURED RESULT ###
  most_occured_exp_driver = max(answer_driver, key=answer_driver.get)
  most_occured_exp_driver = most_occured_exp_driver[::-1]
  driver_best_cost = costos[comb_pos.index(most_occured_exp_driver)]
  driver_vs_theoritical_hamming = hamming_distance(most_occured_exp_driver, comb_pos[ind_costo_minimo])
  best_answers_driver_hamiltonian.append([most_occured_exp_driver, driver_best_cost, driver_vs_theoritical_hamming])
  #########################################################

  ### HAMILTONIAN X + XX DRIVER APPROACH ###
  qc_driver2 = QuantumCircuit(q_reg, c_reg, name='qc_driver2')
  full_circuit5(qc_driver2, q_reg, c_reg, campos, conexions, delta_t_driver, p, campos)
  job_sim_driver2 = aersim.run(qc_driver2, shots=n_exp).result()
  answer_driver2 = job_sim_driver2.get_counts(qc_driver2)
  driver2_eev = 0
  for key, value in answer_driver2.items():
    cost = funcion_costo(key, conexions, campos)
    driver2_eev += (cost*value)/n_exp
  driver2_eevs.append(driver2_eev)
  ######################
  ### SELECT MOST OCCURED RESULT ###
  most_occured_exp_driver2 = max(answer_driver2, key=answer_driver2.get)
  most_occured_exp_driver2 = most_occured_exp_driver2[::-1]
  driver_best_cost2 = costos[comb_pos.index(most_occured_exp_driver2)]
  driver_vs_theoritical_hamming2 = hamming_distance(most_occured_exp_driver2, comb_pos[ind_costo_minimo])
  best_answers_driver_hamiltonian2.append([most_occured_exp_driver2, driver_best_cost2, driver_vs_theoritical_hamming2])
  #########################################################
  # print("\n")

watts_strogatz = [theoretical_minima, rfox_eevs, driver_eevs_a, driver_eevs, driver2_eevs, best_answers_rzx_time_evolution, best_answers_driver_hamiltonian_a, best_answers_driver_hamiltonian, best_answers_driver_hamiltonian2]
output = open('Watts_Strogatz_12n_5_minus_5.pkl', 'wb')
pickle.dump(watts_strogatz, output)

# 1) Recolectar datos
# eev_phase   = np.array(phase_eevs)    # Expected energy value for phase only model.
eev_rfox    = np.array(rfox_eevs)     # Expected energy value for rfox algorithm.
eev_driver_a = np.array(driver_eevs_a)   # Expected energy value for driver X-only model.
eev_driver  = np.array(driver_eevs)   # Expected energy value for driver XX-only model.
eev_driver2  = np.array(driver2_eevs)   # Expected energy value for driver X+XX model.

# cost_phase   = np.array([entry[1] for entry in best_answers_phase_encoding])
cost_rzx     = np.array([entry[1] for entry in best_answers_rzx_time_evolution])
cost_driver_a  = np.array([entry[1] for entry in best_answers_driver_hamiltonian_a])
cost_driver  = np.array([entry[1] for entry in best_answers_driver_hamiltonian])
cost_driver2  = np.array([entry[1] for entry in best_answers_driver_hamiltonian2])
theoretical  = np.array(theoretical_minima)

# hamm_phase   = np.array([entry[2] for entry in best_answers_phase_encoding])
hamm_rzx     = np.array([entry[2] for entry in best_answers_rzx_time_evolution])
hamm_driver_a  = np.array([entry[2] for entry in best_answers_driver_hamiltonian_a])
hamm_driver  = np.array([entry[2] for entry in best_answers_driver_hamiltonian])
hamm_driver2  = np.array([entry[2] for entry in best_answers_driver_hamiltonian2])

instances = np.arange(1, len(theoretical) + 1)

#  --- diferencias vs teórico ---
diff_rfox = cost_rzx - theoretical
# diff_phase = cost_phase - theoretical
diff_driver_a = cost_driver_a - theoretical
diff_driver = cost_driver - theoretical
diff_driver2 = cost_driver2 - theoretical

diff_hamm_rfox    = hamm_rzx
# diff_hamm_phase  = hamm_phase
diff_hamm_driver_a = hamm_driver_a
diff_hamm_driver = hamm_driver
diff_hamm_driver2 = hamm_driver2

labels = ['RFOX', 'X-only', 'XX-only', 'X+XX']
x = np.arange(len(labels))
colors = ['C0','C1','C2','C3']

means_diff_cost = [diff_rfox.mean(), diff_driver_a.mean(), diff_driver.mean(), diff_driver2.mean()]
vars_diff_cost  = [diff_rfox.var(), diff_driver_a.var(), diff_driver.var(), diff_driver2.var()]

means_diff_hamm = [diff_hamm_rfox.mean(), diff_hamm_driver_a.mean(), diff_hamm_driver.mean(), diff_hamm_driver2.mean()]
vars_diff_hamm  = [diff_hamm_rfox.var(), diff_hamm_driver_a.mean(), diff_hamm_driver.var(), diff_hamm_driver2.var()]


# ── Crear figura con GridSpec de 3 filas x 2 columnas ─────────────────────────
fig = plt.figure(constrained_layout=True, figsize=(14, 12))
gs  = fig.add_gridspec(3, 2)

# Fila 0: EEV (ocupa ambas columnas)
ax_cost       = fig.add_subplot(gs[0, :])
# Fila 1: cost & hamming
ax_eev      = fig.add_subplot(gs[1, 0])
ax_hamm      = fig.add_subplot(gs[1, 1])
# Fila 2: diff cost & diff hamming
ax_diff_cost = fig.add_subplot(gs[2, 0])
ax_diff_hamm = fig.add_subplot(gs[2, 1])

# 2) Subgráfica 1: costo mínimo por instancia (fila 0)
ax_cost.plot(instances, cost_rzx, marker='s', label='RFOX')
# ax_cost.plot(instances, cost_phase, marker='o', label='Phase encoding', alpha=0.6)
ax_cost.plot(instances, cost_driver_a, marker='^', label='X-only', alpha=0.6)
ax_cost.plot(instances, cost_driver, marker='*', label='XX-only', alpha=0.6)
ax_cost.plot(instances, cost_driver2, marker='x', label='X+XX', alpha=0.6)
ax_cost.plot(instances, theoretical, linestyle='--', color='gray', label='Theoric minimum')
ax_cost.set_xlabel('Instance', fontsize=18)
ax_cost.set_ylabel('Minimum cost', fontsize=18)
ax_cost.set_title('Minimum cost per instance', fontsize=20)
ax_cost.legend(loc='upper right')
ax_cost.grid(True)

# 3) Subgráfica 2: EEV por instancia (fila 1, col 0)
ax_eev.plot(instances, eev_rfox,    marker='s', label='RFOX')
# ax_eev.plot(instances, eev_phase,   marker='o', label='Phase encoding', alpha=0.6)
ax_eev.plot(instances, eev_driver_a, marker='^', label='X-only', alpha=0.6)
ax_eev.plot(instances, eev_driver,  marker='*', label='XX-only', alpha=0.6)
ax_eev.plot(instances, eev_driver2,  marker='x', label='X+XX', alpha=0.6)
# Línea del mínimo teórico
# ax_eev.plot(instances, theoretical, linestyle='--', color='gray', label='Theoric minimum')
ax_eev.set_xlabel('Instance', fontsize=15)
ax_eev.set_ylabel('Expected Energy Value (EEV)', fontsize=17)
ax_eev.set_title('EEV per instance', fontsize=20)
ax_eev.legend(loc='upper right')
ax_eev.grid(True)


# 4) Subgráfica 3: distancia de Hamming por instancia (fila 1, col 1)
ax_hamm.plot(instances, hamm_rzx,    marker='s', label='RFOX')
# ax_hamm.plot(instances, hamm_phase,  marker='o', label='Phase encoding', alpha=0.6)
ax_hamm.plot(instances, hamm_driver_a, marker='^', label='X-only', alpha=0.6)
ax_hamm.plot(instances, hamm_driver, marker='*', label='XX-only', alpha=0.6)
ax_hamm.plot(instances, hamm_driver2, marker='x', label='X+XX', alpha=0.6)
ax_hamm.set_xlabel('Instance', fontsize=15)
ax_hamm.set_ylabel('Hamming distance', fontsize=17)
ax_hamm.set_title('Hamming distance per instance', fontsize=20)
ax_hamm.legend(loc='upper right')
ax_hamm.grid(True)


# 5) Subgráfica 4: barras de diferencia media de coste (fila 2, col 0)
ax_diff_cost.bar(x, means_diff_cost, yerr=np.sqrt(vars_diff_cost), capsize=5, color=colors)
ax_diff_cost.set_xticks(x)
ax_diff_cost.set_xticklabels(labels, rotation=45, ha='right')
ax_diff_cost.set_ylabel('Δ Mean cost vs theoretic', fontsize=17)
ax_diff_cost.set_title('Cost difference (mean ± σ)', fontsize=20)
ax_diff_cost.grid(axis='y')


# 6) Subgráfica 5: barras de diferencia media de Hamming (fila 2, col 1)
ax_diff_hamm.bar(x, means_diff_hamm, yerr=np.sqrt(vars_diff_hamm), capsize=5, color=colors)
ax_diff_hamm.set_xticks(x)
ax_diff_hamm.set_xticklabels(labels, rotation=45, ha='right')
ax_diff_hamm.set_ylabel('Δ Mean hamming vs theoretic', fontsize=17)
ax_diff_hamm.set_title('Hamming difference (mean ± σ)', fontsize=20)
ax_diff_hamm.grid(axis='y')


# 7) Guardar en EPS y mostrar
plt.savefig('Erdos_Renyi_7n_150_1_minus_1_FULL_COMP_mod.eps', format='eps', bbox_inches='tight')
plt.show()
