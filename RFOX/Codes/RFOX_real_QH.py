"""RFOX.ipynb

Automatically generated by Colab.

Author: Ph.D.(c) Brian García Sarmina 15/08/2025 version 2.1

Original file is located at
    https://colab.research.google.com/drive/---
"""

import numpy as np
import random
import pickle
from itertools import product
import qiskit
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
from qiskit_aer import AerSimulator
from qiskit.visualization import plot_histogram, plot_bloch_multivector
from qiskit.visualization.array import array_to_latex
import matplotlib.pyplot as plt
import networkx as nx
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_ibm_runtime import EstimatorV2 as Estimator
from qiskit_ibm_runtime import SamplerV2 as Sampler


"""###################### RFOX  AND COMPARISON MODELS ##############################"""

### WALSH-HADAMARD TRANSFORM ###
def walsh(qc, q_reg):
  for x in q_reg:
    qc.h(x)
  qc.barrier()
### PHASE INTERFERENCE ##
def phase_int(qc, q_reg, c_reg, phases):
  for j in range(len(phases)):
    ### Strategy for complex problem, [-1, 1] fields.
    qc.p(phases[j], q_reg[j])
  qc.barrier()

### RFOX algorithm BASED IN RXX-RZX GATES ###
def cone_t_ev(qc, q_reg, conexions, delta_t_1, delta_t_2, p, phases):
  for i in range(p):
    ### DRIVER HAMILTONIAN RZX TYPE ###
    for con in conexions:
      qc.rxx((1 - delta_t_2[i]), con[1], con[0])
      qc.rzx(delta_t_1[i], con[1], con[0])

### Vanilla Adiabatic approach ###
def cone(qc, q_reg, conexions, delta_t, p, phases, campos):
  for i in range(len(delta_t)):
    for k in range(len(campos)):
      qc.rx((1-delta_t[i]), q_reg[k])
    ### MAGNETIC FIELD ENCODING ###
    for j in range(len(campos)):
      qc.rz(delta_t[i]*campos[j], q_reg[j])
    qc.barrier()
    for con in conexions:
      qc.rzz(delta_t[i], con[0], con[1])
    qc.barrier()

### XX-DRIVER HAMILTONIAN ###
def cone_t_ev_driver(qc, q_reg, conexions, delta_t, p, phases, campos):
  j_xx = 1
  for i in range(len(delta_t)):
    ### DRIVER HAMILTONIAN RXX TYPE ###
    for con in conexions:
      qc.rxx(j_xx*(1-delta_t[i]), con[0], con[1])
    qc.barrier()
    ### MAGNETIC FIELD ENCODING ###
    for j in range(len(campos)):
      qc.rz(-1*delta_t[i]*campos[j], q_reg[j])
    qc.barrier()
    for con in conexions:
      qc.rzz(-1*delta_t[i], con[0], con[1])
    qc.barrier()

### X + sXX-DRIVER HAMILTONIAN ###
def cone_t_ev_driver_plus(qc, q_reg, conexions, delta_t, p, phases, campos):
  j_x_xx = 1
  for i in range(len(delta_t)):
    for k in range(len(campos)):
      qc.rx(-1*(1-delta_t[i]), q_reg[k])
    ### DRIVER HAMILTONIAN RXX TYPE ###
    for con in conexions:
      qc.rxx(j_x_xx*delta_t[i]*(1-delta_t[i]), con[0], con[1])
    qc.barrier()
    ### MAGNETIC FIELD ENCODING ###
    for j in range(len(campos)):
      qc.rz(-1*delta_t[i]*campos[j], q_reg[j])
    qc.barrier()
    for con in conexions:
      qc.rzz(-1*delta_t[i], con[0], con[1])
    qc.barrier()

### GENERATE FULL CIRCUIT (PHASE ENCODING ONLY) ### WITHOUT INTERACTIONS
def full_circuit1(qc, q_reg, c_reg, phases, conexions, con_val):
  walsh(qc, q_reg)
  phase_int(qc, q_reg, c_reg, phases)
  walsh(qc, q_reg)
  qc.measure(q_reg, c_reg)

### GENERATE FULL CIRCUIT RFOX (NON-Stoquastic + CD Floquet) ####
def full_circuit2(qc, q_reg, c_reg, phases, conexions, delta_t_1, delta_t_2, p):
  walsh(qc, q_reg)
  phase_int(qc, q_reg, c_reg, phases)
  walsh(qc, q_reg)
  cone_t_ev(qc, q_reg, conexions, delta_t_1, delta_t_2, p, phases)
  qc.barrier()
  qc.measure(q_reg, c_reg)

### GENERATE FULL CIRCUIT (XX-only DRIVER HAMILTONIAN) ####
def full_circuit3(qc, q_reg, c_reg, phases, conexions, delta_t, p, campos):
  walsh(qc, q_reg)
  cone_t_ev_driver(qc, q_reg, conexions, delta_t, p, phases, campos)
  qc.measure(q_reg, c_reg)

### GENERATE FULL CIRCUIT (X + sXX DRIVER HAMILTONIAN) ####
def full_circuit4(qc, q_reg, c_reg, phases, conexions, delta_t, p, campos):
  walsh(qc, q_reg)
  cone_t_ev_driver_plus(qc, q_reg, conexions, delta_t, p, phases, campos)
  qc.measure(q_reg, c_reg)

"""### BASE EXPERIMENT ON IBM_BRISBANE ###"""

service = QiskitRuntimeService(channel="ibm_cloud", token="__", instance="__")
backend = service.backend('ibm_brisbane') # Eagle r3: ibm_bribane ; Heron r1: ibm_torino
print(backend)

q_num = 15 # Number of nodes in graph
n = q_num          # número de nodos
h_range = (-3, 3)  # rango para los campos magnéticos
G = nx.Graph()
G.add_nodes_from(np.arange(0, n, 1))
elist = []
for edge in backend.coupling_map:
  if edge[0] < n and edge[1] < n:
    elist.append([edge[0], edge[1]])
G.add_edges_from(elist)

# Asignar un campo magnético aleatorio a cada nodo
for node in G.nodes():
  G.nodes[node]['magnet_field'] = np.random.uniform(h_range[0], h_range[1])

# Preparar los valores del campo magnético para colorear los nodos
magnetic_fields = [G.nodes[node]['magnet_field'] for node in G.nodes()]

# Dibujar nodos con un mapa de colores (cmap) que refleje los valores de los campos magnéticos
pos = nx.spring_layout((G), seed=42)
nodes = nx.draw_networkx_nodes(G, pos, node_color=magnetic_fields, cmap=plt.cm.coolwarm, node_size=200, alpha=0.8)

# Dibujar las aristas y etiquetas
nx.draw_networkx_edges(G, pos, width=2.0, alpha=0.7)
nx.draw_networkx_labels(G, pos, font_color='white')

# Añadir barra de color para identificar el campo magnético
plt.colorbar(nodes, label='Magnetic field')

# Configurar título y quitar ejes
plt.title("RFIM (IBM-Quantum)", fontsize=20)
plt.axis('off')
plt.savefig('IBM_quantum_RFIM_example.eps', format='eps', bbox_inches='tight')

# Mostrar el grafo
plt.show()

"""## RFOX SIM and REAL"""

### Numero de nodos = numero de qubits ###
conexions = list(G.edges())
campos = [datos['magnet_field'] for nodo, datos in G.nodes(data=True)]
print("Campos magnéticos:", campos)
#### Phase encoding para los campos magneticos ####
# Step 1: Divide by the largest absolute value
max_abs = np.max(np.abs(campos))
scaled = campos / max_abs
# Step 2: Shift and scale to [0,1]
normalized_data = (scaled + 1) / 2
normalized = np.array(normalized_data)
norm_phases = normalized*np.pi
print("Norm phases: ", norm_phases)
###################################################

#### ADAPTIVE TIME EVOLUTION ####
t = 1           # tiempo total de evolución
p = 25               # número de trozos

def harmonic_delta_zx(t, delta, n_qubits):
    """
    Función armónica que oscila entre [-delta, +delta] en t∈[0,1],
    con exactamente n_qubits oscilaciones completas.
    """
    return delta * np.sin(2 * np.pi * n_qubits * t)

def harmonic_delta_xx(t, delta, n_qubits):
    """
    Función armónica que oscila entre [-delta, +delta] en t∈[0,1],
    con exactamente n_qubits oscilaciones completas.
    """
    return delta * np.cos(2 * np.pi * n_qubits * t)

delta = 0.01           # amplitud pequeña
n_qubits = q_num        # número de oscilaciones = número de qubits
t_vals = np.linspace(0, 1, p)   # tiempos uniformes en [0,1]
delta_t_1 = harmonic_delta_zx(t_vals, delta, n_qubits)
delta_t_2 = harmonic_delta_xx(t_vals, delta, n_qubits)

### QUANTUM CIRCUIT ###
q_reg = QuantumRegister(q_num)
c_reg = ClassicalRegister(q_num)
qc = QuantumCircuit(q_reg, c_reg, name='qc')
full_circuit2(qc, q_reg, c_reg, norm_phases, conexions, delta_t_1, delta_t_2, p, campos)

pm = generate_preset_pass_manager(optimization_level=3, backend=backend)
candidate_circuit = pm.run(qc)
# candidate_circuit.draw('mpl', fold=False, scale=0.1, idle_wires=False)

n_exp = 20000 # Numero de experimentos
### QUANTUM CIRCUIT ###
q_reg = QuantumRegister(q_num)
c_reg = ClassicalRegister(q_num)
qc_rfox_local = QuantumCircuit(q_reg, c_reg, name='qc_rfox_local')
full_circuit2(qc_rfox_local, q_reg, c_reg, norm_phases, conexions, delta_t_1, delta_t_2, p, campos)

aersim = AerSimulator()
job_sim = aersim.run(qc, shots=n_exp).result()
answer_rfox_local = job_sim.get_counts(qc)
print("Experiment results: ", answer_rfox_local)
max_exp_rfox_local = max(answer_rfox_local.values())
max_state_rfox_local = max(answer_rfox_local, key=answer_rfox_local.get)
print("Most ocurred state: ", max_state_rfox_local, "# exp: ", max_exp_rfox_local)

sampler = Sampler(mode=backend)
job = sampler.run([(candidate_circuit)], shots=20000)
print(f">>> Job ID: {job.job_id()}")
print(f">>> Job Status: {job.status()}")

# Get results for the first (and only) PUB
pub_result = job.result()
print(pub_result)
counts_real_rfox = pub_result[0].data.c29.get_counts()
print(counts_real_rfox)
# plot_histogram(counts_real)
max_exp_rfox = max(counts_real_rfox.values())
max_state_rfox = max(counts_real_rfox, key=counts_real_rfox.get)
print("Most ocurred state: ", max_state_rfox, "# exp: ", max_exp_rfox)

"""## XX-only SIM and REAL"""

#### ADAPTIVE TIME EVOLUTION ####
t = 1           # tiempo total de evolución
p = 25               # número de trozos

#### VALUES FOR DRIVER AND PROBLEM HAMILTONIAN ####
delta_t_driver = np.linspace(0, 1, p)

### QUANTUM CIRCUIT ###
q_reg = QuantumRegister(q_num)
c_reg = ClassicalRegister(q_num)
qc_xx_driver = QuantumCircuit(q_reg, c_reg, name='qc_xx_driver')
full_circuit3(qc_xx_driver, q_reg, c_reg, norm_phases, conexions, delta_t_driver, p, campos)

aersim = AerSimulator()
job_sim_driver = aersim.run(qc_xx_driver, shots=n_exp).result()
answer_xx_local = job_sim_driver.get_counts(qc_xx_driver)
print("Sim XX-only results: ", answer_xx_local)
max_exp_driver = max(answer_xx_local.values())
max_state_driver = max(answer_xx_local, key=answer_xx_local.get)
print("Most ocurred state sim XX-only: ", max_state_driver, "# exp: ", max_exp_driver)

pm_xx = generate_preset_pass_manager(optimization_level=3, backend=backend)
candidate_circuit_xx = pm_xx.run(qc_xx_driver)
sampler_xx = Sampler(mode=backend)
job_xx = sampler_xx.run([(candidate_circuit_xx)], shots=20000)
print(f">>> Job ID: {job_xx.job_id()}")
print(f">>> Job Status: {job_xx.status()}")

# Get results for the first (and only) PUB
pub_result_xx = job_xx.result()
print(pub_result_xx)
counts_real_xx = pub_result_xx[0].data.c38.get_counts()
print(counts_real_xx)
max_exp_xx = max(counts_real_xx.values())
max_state_xx = max(counts_real_xx, key=counts_real_xx.get)
print("Most ocurred state: ", max_state_xx, "# exp: ", max_exp_xx)

"""## X+sXX SIM and REAL"""

#### ADAPTIVE TIME EVOLUTION ####
t = 1           # tiempo total de evolución
p = 25               # número de trozos

#### VALUES FOR DRIVER AND PROBLEM HAMILTONIAN ####
delta_t_driver = np.linspace(0, 1, p)

### QUANTUM CIRCUIT ###
q_reg = QuantumRegister(q_num)
c_reg = ClassicalRegister(q_num)
qc_x_sxx_driver = QuantumCircuit(q_reg, c_reg, name='qc_x_sxx')
full_circuit4(qc_x_sxx_driver, q_reg, c_reg, norm_phases, conexions, delta_t_driver, p, campos)

aersim = AerSimulator()
job_sim_driver2 = aersim.run(qc_x_sxx_driver, shots=n_exp).result()
answer_xsx_local = job_sim_driver2.get_counts(qc_x_sxx_driver)
print("Sim X+sXX results: ", answer_xsx_local)
max_exp_driver2 = max(answer_xsx_local.values())
max_state_driver2 = max(answer_xsx_local, key=answer_xsx_local.get)
print("Most ocurred state sim X+sXX: ", max_state_driver2, "# exp: ", max_exp_driver2)

pm_x_sxx = generate_preset_pass_manager(optimization_level=3, backend=backend)
candidate_circuit_x_sxx = pm_x_sxx.run(qc_x_sxx_driver)
sampler_x_sxx = Sampler(mode=backend)
job_x_sxx = sampler_x_sxx.run([(candidate_circuit_x_sxx)], shots=20000)
print(f">>> Job ID: {job_x_sxx.job_id()}")
print(f">>> Job Status: {job_x_sxx.status()}")

# Get results for the first (and only) PUB
pub_result_x_sxx = job_x_sxx.result()
print(pub_result_x_sxx)
counts_real_xsx = pub_result_x_sxx[0].data.c37.get_counts()
print(counts_real_xsx)
max_exp_x_sxx = max(counts_real_xsx.values())
max_state_x_sxx = max(counts_real_xsx, key=counts_real_xsx.get)
print("Most ocurred state: ", max_state_x_sxx, "# exp: ", max_exp_x_sxx)

"""## SIMULATION and EXPERIMENTAL RESULTS"""

_### PROBAR MEJOR RESULTADO GENERADO ###
comb_pos = []
for bits_tuple in product('01', repeat=q_num):
  bits_str = ''.join(bits_tuple)
  comb_pos.append(bits_str)

def funcion_costo(combinacion, conexions, campos):
  costo = 0
  j_ij = 1
  ### INTERACCIONES ###
  for con in conexions:
    if combinacion[con[0]] == combinacion[con[1]]:
      costo += (-1*j_ij)
    else:
      costo += (1*j_ij)

  ### CAMPOS MAGNETICOS ##
  for i in range(len(combinacion)):
    ### Si el valor es "0" y el campo es negativo ###
    if combinacion[i] == '0' and campos[i] < 0:
      costo += campos[i]
    if combinacion[i] == '0' and campos[i] > 0:
      costo += campos[i]
    ### Si el valor es "1" y el campo es positivo ###
    if combinacion[i] == '1' and campos[i] > 0:
      costo += -1*campos[i]
    if combinacion[i] == '1' and campos[i] < 0:
      costo += -1*campos[i]
  return costo

def hamming_distance(s1, s2):
  if len(s1) != len(s2):
    raise ValueError("Bitstrings must be of the same length.")
  return sum(c1 != c2 for c1, c2 in zip(s1, s2))

### TEST AND COMPARE APPROACHES ###
costos = [funcion_costo(comb, conexions, campos) for comb in comb_pos]
costo_minimo = min(costos)
ind_costo_minimo = costos.index(costo_minimo)
print("Globlal minimum cost: ", costo_minimo)
print("Theoretical minimum comb: ", comb_pos[ind_costo_minimo])

max_state_rfox = max(counts_real_rfox, key=counts_real_rfox.get)
most_state_rfox = max_state_rfox[::-1]
print("Most occured exp RFOX: ", most_state_rfox)
print("Experimental cost of most occured RFOX: ", costos[comb_pos.index(most_state_rfox)])
print("Hamming distance RFOX: ", hamming_distance(most_state_rfox, comb_pos[ind_costo_minimo]))

most_occured_exp = max(answer_rfox_local, key=answer_rfox_local.get)
most_occured_exp = most_occured_exp[::-1]
print("Most occured sim RFOX: ", most_occured_exp)
print("Sim RFOX: ", costos[comb_pos.index(most_occured_exp)])
print("Hamming distance sim RFOX: ", hamming_distance(most_occured_exp, comb_pos[ind_costo_minimo]))

# ------------------  endian fix ------------------
### TEST AND COMPARE APPROACHES ###
costos = [funcion_costo(comb, conexions, campos) for comb in comb_pos]
costo_minimo = min(costos)
ind_costo_minimo = costos.index(costo_minimo)
print("Globlal minimum cost: ", costo_minimo)
print("Theoretical minimum comb: ", comb_pos[ind_costo_minimo])

gs_hw = comb_pos[ind_costo_minimo][::-1]           # flip for backend bit order

def hamming(a, b):
    return sum(c1 != c2 for c1, c2 in zip(a, b))

def overlap_fidelity(winner, gs, n):
    return 1.0 - hamming(winner, gs)/n

# ---------------------------------------------------------------
# 1.  grab the winner for each counts dict
# ---------------------------------------------------------------
winners = {
    "RFOX-real": max(counts_real_rfox, key=counts_real_rfox.get),
    "RFOX-sim" : max(answer_rfox_local, key=answer_rfox_local.get),

    "XX-real"  : max(counts_real_xx,   key=counts_real_xx.get),
    "XX-sim"   : max(answer_xx_local,  key=answer_xx_local.get),

    "X+sXX-real": max(counts_real_xsx, key=counts_real_xsx.get),
    "X+sXX-sim" : max(answer_xsx_local,key=answer_xsx_local.get)
}

# ---------------------------------------------------------------
# 2.  compute fidelities
# ---------------------------------------------------------------
n_qubits = len(gs_hw)
F = {k: overlap_fidelity(v, gs_hw, n_qubits) for k, v in winners.items()}

# ---------------------------------------------------------------
# 3.  plot
# ---------------------------------------------------------------
labels = ["RFOX-real", "RFOX-sim", "XX-real", "XX-sim", "X+sXX-real", "X+sXX-sim"]
vals   = [F[l] for l in labels]

plt.figure(figsize=(8,4))
plt.bar(range(len(labels)), vals, color=["steelblue","lightblue",
                                         "orange","peachpuff",
                                         "seagreen","lightgreen"])
plt.xticks(range(len(labels)), labels, rotation=35, ha='right')
plt.ylim(0,1.1)
plt.ylabel("Overlap fidelity")
plt.title(f"Hamming vs ground state  (n = {n_qubits})")
plt.tight_layout()
plt.grid(axis='y')
plt.savefig('hamming_real_experiments.eps', format='eps', bbox_inches='tight')
plt.show()

# -------------------------------------------------------------
# 0.  imports (add if missing)
# -------------------------------------------------------------
import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial.distance import jensenshannon

# -------------------------------------------------------------
# 1.  helper: counts  →  probability vector on common alphabet
# -------------------------------------------------------------
def probs_from_counts(counts_real, shots_real,
                      counts_sim,  shots_sim):
    """
    Return two aligned probability vectors p, q
    over the union of bit-strings present in either run.
    """
    keys = sorted(set(counts_real) | set(counts_sim))
    p = np.array([counts_real.get(k, 0) / shots_real for k in keys])
    q = np.array([counts_sim .get(k, 0) / shots_sim  for k in keys])
    return p, q

# -------------------------------------------------------------
# 2.  build distance list
# -------------------------------------------------------------
labels = ["RFOX", "XX", "X+sXX"]

js_vals = []

shots_real = shots_sim = 20000

# ------- RFOX ---------
p, q = probs_from_counts(counts_real_rfox,   shots_real,
                         answer_rfox_local,  shots_sim)
js_vals.append(jensenshannon(p, q, base=2))     # distance in [0,1]

# ------- XX ----------
p, q = probs_from_counts(counts_real_xx,     shots_real,
                         answer_xx_local,    shots_sim)
js_vals.append(jensenshannon(p, q, base=2))

# ------- X+sXX -------
p, q = probs_from_counts(counts_real_xsx,    shots_real,
                         answer_xsx_local,   shots_sim)
js_vals.append(jensenshannon(p, q, base=2))

# -------------------------------------------------------------
# 3.  plot
# -------------------------------------------------------------
plt.figure(figsize=(7,5))
bars = plt.bar(labels, js_vals, color=["steelblue","orange","seagreen"])
plt.ylabel("Jensen–Shannon distance  $D_{JS}$")
plt.ylim(0,1.1)
plt.title("Distribution overlap: hardware vs simulator")
for bar, val in zip(bars, js_vals):
    plt.text(bar.get_x() + bar.get_width()/2, val + 0.02,
             f"{val:.3f}", ha='center', va='bottom')
plt.tight_layout()
plt.grid(axis='y')
plt.savefig('jensen_shannon_overlap.eps', format='eps', bbox_inches='tight')
plt.show()

# ------------------------------------------------------------
# 0.  helper: little-endian -> big-endian cost conversion
# ------------------------------------------------------------
def cost_bitstring_le(bitstring_le, connex, fields):
    """Energy of little-endian bitstring (hardware order)."""
    bs_be = bitstring_le[::-1]           # flip to big-endian
    return funcion_costo(bs_be, connex, fields)

def energy_moments(counts, shots, connex, fields):
    """Return <E>, <E^2> from a counts dict."""
    exp_E  = 0.0
    exp_E2 = 0.0
    for bs, c in counts.items():
        p  = c / shots
        E  = cost_bitstring_le(bs, connex, fields)
        exp_E  += p * E
        exp_E2 += p * E * E
    return exp_E, exp_E2

def variance_E(counts, shots, connex, fields):
    exp_E, exp_E2 = energy_moments(counts, shots, connex, fields)
    return exp_E2 - exp_E**2

# ------------------------------------------------------------
# 1.  calculate variances
# ------------------------------------------------------------
shots_real = 20_000
shots_sim  = n_exp

var_real_rfox = variance_E(counts_real_rfox,   shots_real, conexions, campos)
var_sim_rfox  = variance_E(answer_rfox_local,  shots_sim,  conexions, campos)

var_real_xx   = variance_E(counts_real_xx,     shots_real, conexions, campos)
var_sim_xx    = variance_E(answer_xx_local,    shots_sim,  conexions, campos)

var_real_xsx  = variance_E(counts_real_xsx,    shots_real, conexions, campos)
var_sim_xsx   = variance_E(answer_xsx_local,   shots_sim,  conexions, campos)

# ------------------------------------------------------------
# 2.  plot
# ------------------------------------------------------------
labels = ["RFOX", "XX", "X+sXX"]
real_vars = [var_real_rfox, var_real_xx, var_real_xsx]
sim_vars  = [var_sim_rfox,  var_sim_xx,  var_sim_xsx]

x = np.arange(len(labels)); w = 0.35
fig, ax = plt.subplots(figsize=(7,4))
ax.bar(x-w/2, real_vars, width=w, label="Hardware",  color="steelblue")
ax.bar(x+w/2, sim_vars,  width=w, label="Simulator", color="lightblue")

ax.set_xticks(x)
ax.set_xticklabels(labels)
ax.set_ylabel("Energy variance  $\\operatorname{Var}(H_P)$")
ax.set_title("Diabatic leakage proxy: energy variance")
ax.legend()
plt.tight_layout()
plt.show()

# ----------------------------------------------------------------------
# 0. helpers
# ----------------------------------------------------------------------
def hamming(a, b):
    return sum(c1 != c2 for c1, c2 in zip(a, b))

def avg_hamming(counts, shots, gs_le):
    """Weighted Hamming distance from each measured bit-string to ground state (little-endian)."""
    return sum(cnt * hamming(bs, gs_le) for bs, cnt in counts.items()) / shots

# ground-state string: flip big-endian -> little-endian
gs_le = comb_pos[ind_costo_minimo][::-1]           #   gs_string came from comb_pos earlier
n_qubits = len(gs_le)

# ----------------------------------------------------------------------
# 1. average distances
# ----------------------------------------------------------------------
shots_real = 20_000     # adjust if different
shots_sim  = n_exp

avg_dist = {
    "RFOX-hw" : avg_hamming(counts_real_rfox,   shots_real, gs_le),
    "RFOX-sim": avg_hamming(answer_rfox_local,  shots_sim,  gs_le),

    "XX-hw"   : avg_hamming(counts_real_xx,     shots_real, gs_le),
    "XX-sim"  : avg_hamming(answer_xx_local,    shots_sim,  gs_le),

    "X+sXX-hw": avg_hamming(counts_real_xsx,    shots_real, gs_le),
    "X+sXX-sim":avg_hamming(answer_xsx_local,   shots_sim,  gs_le)
}

# ----------------------------------------------------------------------
# 2. plot
# ----------------------------------------------------------------------
labels = ["RFOX", "XX", "X+sXX"]
hw_vals  = [avg_dist[f"{lbl}-hw"]  for lbl in labels]
sim_vals = [avg_dist[f"{lbl}-sim"] for lbl in labels]

x = np.arange(len(labels))
w = 0.35
fig, ax = plt.subplots(figsize=(7,4))
ax.bar(x-w/2, hw_vals,  width=w, label="Hardware",  color="steelblue")
ax.bar(x+w/2, sim_vals, width=w, label="Simulator", color="lightblue")

ax.set_xticks(x)
ax.set_xticklabels(labels)
ax.set_ylabel(r"Average Hamming distance")
ax.set_title("Average distance from ground state")
ax.set_ylim(0, n_qubits-2)
ax.legend()
for i,(h,s) in enumerate(zip(hw_vals, sim_vals)):
    ax.text(i-w/2, h+0.1, f"{h:.1f}", ha='center')
    ax.text(i+w/2, s+0.1, f"{s:.1f}", ha='center')
plt.tight_layout()
plt.grid(axis='y')
plt.savefig('hamming_avg_distance.eps', format='eps', bbox_inches='tight')
plt.show()

"""################# GENERAL TESTS FOR RFIM ON IBM QUANTUM HARDWARE ###########"""

service = QiskitRuntimeService(channel="ibm_cloud", token="__", instance="__")
backend = service.backend('ibm_sherbrooke') # Eagle r3: ibm_sherbrooke ; Heron r1: ibm_torino
print(backend)

# Parámetros del grafo:
q_nums = [12, 15, 20]
h_ranges = [(-1, 1), (-2, 2), (-3, 3)]   # rango para los campos magnéticos
list_of_graphs = []
for i in range(len(q_nums)):
  for j in range(len(h_ranges)):
    h_range = h_ranges[j]
    n = q_nums[i]
    G = nx.Graph()
    G.add_nodes_from(np.arange(0, n, 1))
    elist = []
    for edge in backend.coupling_map:
      if edge[0] < n and edge[1] < n:
        elist.append([edge[0], edge[1]])
    G.add_edges_from(elist)
    # Asignar un campo magnético aleatorio a cada nodo
    for node in G.nodes():
        G.nodes[node]['magnet_field'] = np.random.uniform(h_range[0], h_range[1])
    # Obtener una disposición de los nodos para la visualización
    pos = nx.spring_layout((G))
    # Preparar los valores del campo magnético para colorear los nodos
    magnetic_fields = [G.nodes[node]['magnet_field'] for node in G.nodes()]
    list_of_graphs.append([G, h_range, n])

print(list_of_graphs)

output = open('Problems_RFIM_generated_torino.pkl', 'wb')
pickle.dump(list_of_graphs,output)
data = list_of_graphs

pick_read = open('Problems_RFIM_generated.pkl','rb')
data = pickle.load(pick_read)
print(data)

"""### RFOX ###"""

############################ RFOX LOCAL ##########################
#### ADAPTIVE TIME EVOLUTION ####
t = 1           # tiempo total de evolución
p = 50               # número de trozos
n_exp = 10000 # Numero de experimentos
rfox_local_results = []

for problem in data:
  G = problem[0]
  campos = [datos['magnet_field'] for nodo, datos in G.nodes(data=True)]
  h_range = problem[1]
  n = problem[2]
  ### Numero de nodos = numero de qubits ###
  conexions = list(G.edges())
  # print("Campos magnéticos:", campos)
  #### Phase encoding para los campos magneticos ####
  # Step 1: Divide by the largest absolute value
  max_abs = np.max(np.abs(campos))
  scaled = campos / max_abs
  # Step 2: Shift and scale to [0,1]
  normalized_data = (scaled + 1) / 2
  normalized = np.array(normalized_data)
  norm_phases = normalized*np.pi
  # print("Norm phases: ", norm_phases)
  ###################################################

  def harmonic_delta_zx(t, delta, n_qubits):
      """
      Función armónica que oscila entre [-delta, +delta] en t∈[0,1],
      con exactamente n_qubits oscilaciones completas.
      """
      return delta * np.sin(2 * np.pi * n_qubits * t)

  def harmonic_delta_xx(t, delta, n_qubits):
      """
      Función armónica que oscila entre [-delta, +delta] en t∈[0,1],
      con exactamente n_qubits oscilaciones completas.
      """
      return delta * np.cos(2 * np.pi * n_qubits * t)

  delta = 0.001           # amplitud pequeña
  q_num = n
  n_qubits = q_num        # número de oscilaciones = número de qubits
  t_vals = np.linspace(0, 1, p)   # tiempos uniformes en [0,1]
  delta_t_1 = harmonic_delta_zx(t_vals, delta, n_qubits)
  delta_t_2 = harmonic_delta_xx(t_vals, delta, n_qubits)

  ### QUANTUM CIRCUIT ###
  q_reg = QuantumRegister(q_num)
  c_reg = ClassicalRegister(q_num)
  qc = QuantumCircuit(q_reg, c_reg, name='qc')
  full_circuit2(qc, q_reg, c_reg, norm_phases, conexions, delta_t_1, delta_t_2, p, campos)
  ### QUANTUM CIRCUIT ###
  q_reg = QuantumRegister(q_num)
  c_reg = ClassicalRegister(q_num)
  qc_rfox_local = QuantumCircuit(q_reg, c_reg, name='qc_rfox_local')
  full_circuit2(qc_rfox_local, q_reg, c_reg, norm_phases, conexions, delta_t_1, delta_t_2, p, campos)

  aersim = AerSimulator()
  job_sim = aersim.run(qc, shots=n_exp).result()
  answer_rfox_local = job_sim.get_counts(qc)
  # print("Experiment results: ", answer_rfox_local)
  # max_exp_rfox_local = max(answer_rfox_local.values())
  # max_state_rfox_local = max(answer_rfox_local, key=answer_rfox_local.get)
  # print("Most ocurred state: ", max_state_rfox_local, "# exp: ", max_exp_rfox_local)
  rfox_local_results.append(answer_rfox_local)

print(rfox_local_results)
output3 = open('RFOX_sim_results_sher.pkl', 'wb')
pickle.dump(rfox_local_results, output3)

#############################   RFOX REAL  #############################################
#### ADAPTIVE TIME EVOLUTION ####
t = 1           # tiempo total de evolución
p = 50               # número de trozos
n_exp = 10000 # Numero de experimentos
rfox_real_results = []

for problem in data:
  G = problem[0]
  campos = [datos['magnet_field'] for nodo, datos in G.nodes(data=True)]
  h_range = problem[1]
  n = problem[2]
  ### Numero de nodos = numero de qubits ###
  conexions = list(G.edges())
  # print("Campos magnéticos:", campos)
  #### Phase encoding para los campos magneticos ####
  # Step 1: Divide by the largest absolute value
  max_abs = np.max(np.abs(campos))
  scaled = campos / max_abs
  # Step 2: Shift and scale to [0,1]
  normalized_data = (scaled + 1) / 2
  normalized = np.array(normalized_data)
  norm_phases = normalized*np.pi
  # print("Norm phases: ", norm_phases)
  ###################################################

  def harmonic_delta_zx(t, delta, n_qubits):
      """
      Función armónica que oscila entre [-delta, +delta] en t∈[0,1],
      con exactamente n_qubits oscilaciones completas.
      """
      return delta * np.sin(2 * np.pi * n_qubits * t)

  def harmonic_delta_xx(t, delta, n_qubits):
      """
      Función armónica que oscila entre [-delta, +delta] en t∈[0,1],
      con exactamente n_qubits oscilaciones completas.
      """
      return delta * np.cos(2 * np.pi * n_qubits * t)

  delta = 0.001           # amplitud pequeña
  q_num = n
  n_qubits = q_num        # número de oscilaciones = número de qubits
  t_vals = np.linspace(0, 1, p)   # tiempos uniformes en [0,1]
  delta_t_1 = harmonic_delta_zx(t_vals, delta, n_qubits)
  delta_t_2 = harmonic_delta_xx(t_vals, delta, n_qubits)

  ### QUANTUM CIRCUIT ###
  q_reg = QuantumRegister(q_num)
  c_reg = ClassicalRegister(q_num)
  qc = QuantumCircuit(q_reg, c_reg, name='qc')
  full_circuit2(qc, q_reg, c_reg, norm_phases, conexions, delta_t_1, delta_t_2, p, campos)

  pm = generate_preset_pass_manager(optimization_level=3, backend=backend)
  candidate_circuit = pm.run(qc)
  sampler = Sampler(mode=backend)
  job = sampler.run([(candidate_circuit)], shots=n_exp)
  print(f">>> Job ID: {job.job_id()}")
  print(f">>> Job Status: {job.status()}")

  # Get results for the first (and only) PUB
  pub_result = job.result()
  print(pub_result)
  rfox_real_results.append(pub_result)

print(rfox_real_results)

counts_rfox_real = []
for prim in rfox_real_results:          # PrimitiveResult
    pub      = prim[0]                  # SamplerPubResult
    data_bin = pub.data                 # DataBin wrapper

    # Grab the single BitArray attribute (c0, c1, …)
    bitarray = next(iter(data_bin.__dict__.values()))
    counts_rfox_real.append(bitarray.get_counts())

print(counts_rfox_real)

output2 = open('RFOX_real_results_sher.pkl', 'wb')
pickle.dump(counts_rfox_real, output2)

"""### XX-only"""

#### ADAPTIVE TIME EVOLUTION ####
t = 1           # tiempo total de evolución
p = 50               # número de trozos
n_exp = 10000 # Numero de experimentos
xx_local_results = []

#### VALUES FOR DRIVER AND PROBLEM HAMILTONIAN ####
delta_t_driver = np.linspace(0, 1, p)

for problem in data:
  G = problem[0]
  campos = [datos['magnet_field'] for nodo, datos in G.nodes(data=True)]
  h_range = problem[1]
  n = problem[2]
  q_num = n
  ### Numero de nodos = numero de qubits ###
  conexions = list(G.edges())
  #### Phase encoding para los campos magneticos ####
  # Step 1: Divide by the largest absolute value
  max_abs = np.max(np.abs(campos))
  scaled = campos / max_abs
  # Step 2: Shift and scale to [0,1]
  normalized_data = (scaled + 1) / 2
  normalized = np.array(normalized_data)
  norm_phases = normalized*np.pi
  ###################################################
  ### QUANTUM CIRCUIT ###
  q_reg = QuantumRegister(q_num)
  c_reg = ClassicalRegister(q_num)
  qc_xx_driver = QuantumCircuit(q_reg, c_reg, name='qc_xx_driver')
  full_circuit3(qc_xx_driver, q_reg, c_reg, norm_phases, conexions, delta_t_driver, p, campos)

  aersim = AerSimulator()
  job_sim_driver = aersim.run(qc_xx_driver, shots=n_exp).result()
  answer_xx_local = job_sim_driver.get_counts(qc_xx_driver)
  # print("Sim XX-only results: ", answer_xx_local)
  max_exp_driver = max(answer_xx_local.values())
  max_state_driver = max(answer_xx_local, key=answer_xx_local.get)
  # print("Most ocurred state sim XX-only: ", max_state_driver, "# exp: ", max_exp_driver)
  xx_local_results.append(answer_xx_local)

output4 = open('XX_sim_results_sher.pkl', 'wb')
pickle.dump(xx_local_results, output4)
print(xx_local_results)

# output4 = open('XX_sim_results.pkl', 'wb')
# pickle.dump(xx_local_results, output4)

#### ADAPTIVE TIME EVOLUTION ####
t = 1           # tiempo total de evolución
p = 50               # número de trozos
n_exp = 10000 # Numero de experimentos
xx_real_results = []

#### VALUES FOR DRIVER AND PROBLEM HAMILTONIAN ####
delta_t_driver = np.linspace(0, 1, p)

for problem in data:
  G = problem[0]
  campos = [datos['magnet_field'] for nodo, datos in G.nodes(data=True)]
  h_range = problem[1]
  n = problem[2]
  q_num = n
  ### Numero de nodos = numero de qubits ###
  conexions = list(G.edges())
  #### Phase encoding para los campos magneticos ####
  # Step 1: Divide by the largest absolute value
  max_abs = np.max(np.abs(campos))
  scaled = campos / max_abs
  # Step 2: Shift and scale to [0,1]
  normalized_data = (scaled + 1) / 2
  normalized = np.array(normalized_data)
  norm_phases = normalized*np.pi
  ###################################################
  ### QUANTUM CIRCUIT ###
  q_reg = QuantumRegister(q_num)
  c_reg = ClassicalRegister(q_num)
  qc_xx_driver = QuantumCircuit(q_reg, c_reg, name='qc_xx_driver')
  full_circuit3(qc_xx_driver, q_reg, c_reg, norm_phases, conexions, delta_t_driver, p, campos)

  pm_xx = generate_preset_pass_manager(optimization_level=3, backend=backend)
  candidate_circuit_xx = pm_xx.run(qc_xx_driver)
  sampler_xx = Sampler(mode=backend)
  job_xx = sampler_xx.run([(candidate_circuit_xx)], shots=n_exp)
  print(f">>> Job ID: {job_xx.job_id()}")
  print(f">>> Job Status: {job_xx.status()}")

  # Get results for the first (and only) PUB
  pub_result_xx = job_xx.result()
  xx_real_results.append(pub_result_xx)

print(xx_real_results)
counts_xx_real = []
for prim in xx_real_results:          # PrimitiveResult
    pub      = prim[0]                  # SamplerPubResult
    data_bin = pub.data                 # DataBin wrapper
    # Grab the single BitArray attribute (c0, c1, …)
    bitarray = next(iter(data_bin.__dict__.values()))
    counts_xx_real.append(bitarray.get_counts())
print(counts_xx_real)

output5 = open('XX_real_results_sher.pkl', 'wb')
pickle.dump(counts_xx_real, output5)

"""### X+sXX"""

#### ADAPTIVE TIME EVOLUTION ####
t = 1           # tiempo total de evolución
p = 50               # número de trozos
n_exp = 10000 # Numero de experimentos
xsx_local_results = []

#### VALUES FOR DRIVER AND PROBLEM HAMILTONIAN ####
delta_t_driver = np.linspace(0, 1, p)

for problem in data:
  G = problem[0]
  campos = [datos['magnet_field'] for nodo, datos in G.nodes(data=True)]
  h_range = problem[1]
  n = problem[2]
  q_num = n
  ### Numero de nodos = numero de qubits ###
  conexions = list(G.edges())
  #### Phase encoding para los campos magneticos ####
  # Step 1: Divide by the largest absolute value
  max_abs = np.max(np.abs(campos))
  scaled = campos / max_abs
  # Step 2: Shift and scale to [0,1]
  normalized_data = (scaled + 1) / 2
  normalized = np.array(normalized_data)
  norm_phases = normalized*np.pi
  ###################################################
  ### QUANTUM CIRCUIT ###
  q_reg = QuantumRegister(q_num)
  c_reg = ClassicalRegister(q_num)
  qc_x_sxx_driver = QuantumCircuit(q_reg, c_reg, name='qc_x_sxx')
  full_circuit4(qc_x_sxx_driver, q_reg, c_reg, norm_phases, conexions, delta_t_driver, p, campos)

  aersim = AerSimulator()
  job_sim_driver2 = aersim.run(qc_x_sxx_driver, shots=n_exp).result()
  answer_xsx_local = job_sim_driver2.get_counts(qc_x_sxx_driver)
  # print("Sim X+sXX results: ", answer_xsx_local)
  max_exp_driver2 = max(answer_xsx_local.values())
  max_state_driver2 = max(answer_xsx_local, key=answer_xsx_local.get)
  # print("Most ocurred state sim X+sXX: ", max_state_driver2, "# exp: ", max_exp_driver2)
  xsx_local_results.append(answer_xsx_local)

output6 = open('X_sXX_sim_results_sher.pkl', 'wb')
pickle.dump(xsx_local_results, output6)
print(xsx_local_results)

# output6 = open('X_sXX_sim_results.pkl', 'wb')
# pickle.dump(xsx_local_results, output6)

#### ADAPTIVE TIME EVOLUTION ####
t = 1           # tiempo total de evolución
p = 50               # número de trozos
n_exp = 10000 # Numero de experimentos
xsx_real_results = []

#### VALUES FOR DRIVER AND PROBLEM HAMILTONIAN ####
delta_t_driver = np.linspace(0, 1, p)

for problem in data:
  G = problem[0]
  campos = [datos['magnet_field'] for nodo, datos in G.nodes(data=True)]
  h_range = problem[1]
  n = problem[2]
  q_num = n
  ### Numero de nodos = numero de qubits ###
  conexions = list(G.edges())
  #### Phase encoding para los campos magneticos ####
  # Step 1: Divide by the largest absolute value
  max_abs = np.max(np.abs(campos))
  scaled = campos / max_abs
  # Step 2: Shift and scale to [0,1]
  normalized_data = (scaled + 1) / 2
  normalized = np.array(normalized_data)
  norm_phases = normalized*np.pi
  ###################################################
  ### QUANTUM CIRCUIT ###
  q_reg = QuantumRegister(q_num)
  c_reg = ClassicalRegister(q_num)
  qc_x_sxx_driver = QuantumCircuit(q_reg, c_reg, name='qc_x_sxx')
  full_circuit4(qc_x_sxx_driver, q_reg, c_reg, norm_phases, conexions, delta_t_driver, p, campos)

  pm_x_sxx = generate_preset_pass_manager(optimization_level=3, backend=backend)
  candidate_circuit_x_sxx = pm_x_sxx.run(qc_x_sxx_driver)
  sampler_x_sxx = Sampler(mode=backend)
  job_x_sxx = sampler_x_sxx.run([(candidate_circuit_x_sxx)], shots=n_exp)
  print(f">>> Job ID: {job_x_sxx.job_id()}")
  print(f">>> Job Status: {job_x_sxx.status()}")

  # Get results for the first (and only) PUB
  pub_result_x_sxx = job_x_sxx.result()
  xsx_real_results.append(pub_result_x_sxx)

print(xsx_real_results)
counts_x_sxx_real = []
for prim in xsx_real_results:          # PrimitiveResult
    pub      = prim[0]                  # SamplerPubResult
    data_bin = pub.data                 # DataBin wrapper
    # Grab the single BitArray attribute (c0, c1, …)
    bitarray = next(iter(data_bin.__dict__.values()))
    counts_x_sxx_real.append(bitarray.get_counts())
print(counts_x_sxx_real)

output7 = open('X_sXX_real_results_torino.pkl', 'wb')
pickle.dump(counts_x_sxx_real, output7)

"""# Comparison graphs hardware vs simulations"""

pick_read_1 = open('RFOX_sim_results_sher.pkl','rb')
rfox_local_results = pickle.load(pick_read_1)
pick_read_2 = open('XX_sim_results_sher.pkl','rb')
xx_local_results = pickle.load(pick_read_2)
pick_read_3 = open('X_sXX_sim_results_sher.pkl','rb')
xsx_local_results = pickle.load(pick_read_3)
pick_read_4 = open('RFOX_real_results_sher.pkl','rb')
counts_rfox_real = pickle.load(pick_read_4)
pick_read_5 = open('XX_real_results_sher.pkl','rb')
counts_xx_real = pickle.load(pick_read_5)
pick_read_6 = open('X_sXX_real_results_sher.pkl','rb')
counts_x_sxx_real = pickle.load(pick_read_6)

# output7 = open('X_sXX_real_results_sher.pkl', 'wb')
# pickle.dump(counts_x_sxx_real, output7)

import itertools
from collections import Counter
from scipy.spatial.distance import jensenshannon

# ------------ helper: overlap fidelity ------------------------------
def avg_hamming(counts, shots, gs):
    return sum(cnt * sum(b1!=b2 for b1,b2 in zip(bs, gs))
               for bs, cnt in counts.items()) / shots

def overlap_fid(avg_ham, n):
    return 1.0 - avg_ham/n

# ------------ compute F_overlap for 9 problems ----------------------
drv_names = ["RFOX", "XX", "X+sXX"]
sim_sets  = [rfox_local_results, xx_local_results, xsx_local_results]
hw_sets   = [counts_rfox_real,   counts_xx_real,   counts_x_sxx_real]

F_sim, F_hw = {d: [] for d in drv_names}, {d: [] for d in drv_names}

for idx, (G, h_rng, n) in enumerate(data):
    edges  = np.asarray(G.edges())
    fields = np.array([G.nodes[v]['magnet_field'] for v in G.nodes()])
    # brute‐force optimum (big-endian string)
    gs_be = min((''.join(bits) for bits in itertools.product('01', repeat=n)),
                key=lambda bs: sum((1-2*int(bs[u]))*(1-2*int(bs[v])) for u,v in edges)
                              + sum((1-2*int(bs[j]))*fields[j] for j in range(n)))
    gs_le = gs_be[::-1]

    for j, d in enumerate(drv_names):
        # ---- simulator (big-endian keys) → flip
        cnt_sim_be = sim_sets[j][idx]
        cnt_sim_le = {k[::-1]: v for k, v in cnt_sim_be.items()}
        shots_sim  = sum(cnt_sim_le.values())
        F_sim[d].append(overlap_fid(avg_hamming(cnt_sim_le, shots_sim, gs_le), n))

        # ---- hardware (already little-endian)
        cnt_hw   = hw_sets[j][idx]
        shots_hw = sum(cnt_hw.values())
        F_hw[d].append(overlap_fid(avg_hamming(cnt_hw, shots_hw, gs_le), n))

# ----------------------- plotting -----------------------------------
labels   = [f"{n}q\n({h_rng[0]},{h_rng[1]})" for _, h_rng, n in data]
x        = np.arange(len(labels))
w        = 0.22
offsets  = [-0.25, 0.0, 0.25]              # RFOX, XX, X+sXX

# colour pairs: (hardware, simulator)
col_pairs = {"RFOX":("steelblue", "lightsteelblue"),
             "XX"  :("darkorange", "moccasin"),
             "X+sXX":("seagreen",  "lightgreen")}

plt.figure(figsize=(12,4))
for k, d in enumerate(drv_names):
    hw_col, sim_col = col_pairs[d]
    pos = x + offsets[k]
    plt.bar(pos, F_hw[d],  width=w,  color=hw_col,   label=f"{d} (hw)")
    plt.bar(pos, F_sim[d], width=w,  color=sim_col, alpha=0.55,
            label=f"{d} (sim)")

plt.xticks(x, labels, rotation=30)
plt.ylabel("Overlap fidelity  $F_{\\mathrm{overlap}}$", fontsize=18)
plt.ylim(0,1)
plt.title("Winner-string overlap fidelity: hardware vs simulator", fontsize=20)
plt.legend(ncol=3, fontsize=7)
plt.tight_layout()
plt.savefig('Overlap_Fidelity_Sherbrooke.eps', format='eps', bbox_inches='tight')
plt.show()

# ------------------------------------------------------------------
# helper: align two counts dicts → prob vectors over common alphabet
# ------------------------------------------------------------------
def prob_vectors(counts_a, counts_b):
    keys = sorted(set(counts_a) | set(counts_b))
    shots_a, shots_b = sum(counts_a.values()), sum(counts_b.values())
    p = np.array([counts_a.get(k, 0)/shots_a for k in keys], dtype=float)
    q = np.array([counts_b.get(k, 0)/shots_b for k in keys], dtype=float)
    return p, q

# ------------------------------------------------------------------
# compute JS distance for 9 problems × 3 drivers
# ------------------------------------------------------------------
drivers  = ["RFOX", "XX", "X+sXX"]
sim_sets = [rfox_local_results, xx_local_results, xsx_local_results]
hw_sets  = [counts_rfox_real,   counts_xx_real,   counts_x_sxx_real]

JS = {d: [] for d in drivers}                 # store 9 values per driver

for prob_idx in range(len(data)):             # 0..8
    for d_idx, drv in enumerate(drivers):
        p_sim, p_hw = prob_vectors(sim_sets[d_idx][prob_idx],
                                   hw_sets [d_idx][prob_idx])
        JS[drv].append(jensenshannon(p_sim, p_hw, base=2))  # distance in [0,1]

# ------------------------------------------------------------------
# plot grouped bars (problems on x-axis)
# ------------------------------------------------------------------
labels = [f"{n}q\n{h}" for (G,h,n) in data]
x      = np.arange(len(labels))
width  = 0.22
offset = [-0.25, 0.0, 0.25]
colors = ["steelblue","orange","seagreen"]

plt.figure(figsize=(10,4))
for k,drv in enumerate(drivers):
    plt.bar(x + offset[k], JS[drv], width, color=colors[k], label=drv)

plt.xticks(x, labels, rotation=30)
plt.ylabel("Jensen–Shannon distance  $D_{JS}$", fontsize=15)
plt.ylim(0,1.1)
plt.title("Sim-vs-hardware Jensen–Shannon distance per problem", fontsize=20)
plt.legend()
plt.tight_layout()
plt.savefig('Jensen_Shannon_Sherbrooke.eps', format='eps', bbox_inches='tight')
plt.show()

#--------------------------------------------------------------------
# 0. helpers
#--------------------------------------------------------------------
def fields_from_graph(G, n):
    f = np.zeros(n)
    for v in G.nodes():
        f[v] = G.nodes[v]['magnet_field']
    return f

def cost_energy(bs_be, edges, fields):
    z = 1 - 2*np.fromiter(map(int, bs_be), int)        # ±1
    return np.sum(z[edges[:,0]]*z[edges[:,1]]) + z @ fields

def brute_min_string(n, edges, fields):
    best_E, best_bs = np.inf, None
    for bits in itertools.product('01', repeat=n):
        bs = ''.join(bits)
        E  = cost_energy(bs, edges, fields)
        if E < best_E:
            best_E, best_bs = E, bs
    return best_bs                     # big-endian

def avg_hamming(counts_le, shots, gs_le):
    return sum(cnt*sum(b1!=b2 for b1,b2 in zip(bs,gs_le))
               for bs,cnt in counts_le.items()) / shots

#--------------------------------------------------------------------
# 1. compute ⟨d_H⟩ for 9 problems × 3 drivers
#--------------------------------------------------------------------
drivers  = ["RFOX", "XX", "X+sXX"]
sim_sets = [rfox_local_results, xx_local_results, xsx_local_results]
hw_sets  = [counts_rfox_real,   counts_xx_real,   counts_x_sxx_real]

Ham_sim, Ham_hw = {d: [] for d in drivers}, {d: [] for d in drivers}

for idx,(G, h_rng, n) in enumerate(data):
    edges  = np.asarray(G.edges(), int)
    fields = fields_from_graph(G, n)
    gs_be  = brute_min_string(n, edges, fields)
    gs_le  = gs_be[::-1]

    for j,drv in enumerate(drivers):
        # --- simulator (big-endian keys) -> flip to little-endian
        cnt_sim_be  = sim_sets[j][idx]
        cnt_sim_le  = {k[::-1]: v for k,v in cnt_sim_be.items()}
        Ham_sim[drv].append(avg_hamming(cnt_sim_le, sum(cnt_sim_le.values()), gs_le))

        # --- hardware (already little-endian)
        cnt_hw      = hw_sets[j][idx]
        Ham_hw[drv].append(avg_hamming(cnt_hw, sum(cnt_hw.values()), gs_le))

#--------------------------------------------------------------------
# 2. plot – overlapped bars, distinct colours
#--------------------------------------------------------------------
labels = [f"{n}q\n({h_rng[0]},{h_rng[1]})" for _,h_rng,n in data]
x      = np.arange(len(labels))
w      = 0.22
offs   = [-0.25, 0.0, 0.25]
col    = dict(RFOX=("steelblue","lightsteelblue"),
              XX   =("darkorange","moccasin"),
              X_sXX=("seagreen","lightgreen"))

plt.figure(figsize=(12,4))
for k,drv in enumerate(drivers):
    hw_col, sim_col = col[drv if drv!="X+sXX" else "X_sXX"]
    pos = x + offs[k]
    plt.bar(pos, Ham_hw[drv],  width=w, color=hw_col, label=f"{drv} (hw)")
    plt.bar(pos, Ham_sim[drv], width=w, color=sim_col, alpha=0.45,
            label=f"{drv} (sim)")

plt.xticks(x, labels, rotation=30)
plt.ylabel("Average Hamming distance  $\\langle d_{H}\\rangle$", fontsize=15)
plt.ylim(0, max(max(Ham_hw[d]) for d in drivers)+3)
plt.title("Average Hamming distance: hardware vs simulator", fontsize=20)
plt.legend(ncol=3, fontsize=7)
plt.tight_layout()
plt.savefig('Average_Hamming_Sherbrooke.eps', format='eps', bbox_inches='tight')
plt.show()

